; HT-Bash
; Licensed under the GNU General Public License v3 (GPL v3)
; Copyright (c) 2026 TheMaster1127 aka Mr. Compiler
; 
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program. If not, see <https://www.gnu.org/licenses/>.
;

include "HT-Lib.htvm"

func str getLastChars(str line, int count) {
    str out := ""
    str out_temp := ""
    int len := StrLen(line)
    Loop, count {
        len--
        Loop, Parse, line {
            if (A_Index = len) {
                out_temp := A_LoopField
            }
        }
        out := out_temp . out
    }
    return out
}

func str restoreStrings_bash(str codeOUT, str keyWordEscpaeChar := Chr(92)) {
    Loop, % HT_LIB_theIdNumOfThe34 {
        if (HT_LIB_theIdNumOfThe34 = A_Index + 1) {
            
            if (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\a")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\b")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\e")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\f")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\r")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\t")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\v")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\n")) {
                codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), "$" . StrReplace(StrReplace(StrReplace(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], Chr(34), Chr(39)), "$", "\$"), keyWordEscpaeChar, "\") . Chr(39))
            } else {
                codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(StrReplace(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "$", "\$"), keyWordEscpaeChar, "\") . Chr(34))
            }
            
        }
        else {
            if (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\a")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\b")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\e")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\f")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\r")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\t")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\v")) or (InStr(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "\n")) {
                codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), "$" . StrReplace(StrReplace(StrReplace(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], Chr(34), Chr(39)), "$", "\$"), keyWordEscpaeChar, "\"))
            } else {
                codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(StrReplace(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], "$", "\$"), keyWordEscpaeChar, "\"))
            }
            
        }
    }
    return codeOUT
}



func str transformBracesToHT_Bash(str code) {
    str out := ""
    arr str blockStack
    int ifNestLevel := 0
    int loopNestLevel := 0

    Loop, Parse, code, `n, `r {
        str currentLine := A_LoopField
        str trimmedLine := StrLower(Trim(currentLine))

        if (SubStr(trimmedLine, 1, 5) = "func ") {
            blockStack.add("func:0")
            out .= currentLine . Chr(10)
            continue
        }
        
        ; ===================================================================
        ; IF BLOCKS
        ; ===================================================================
        if (SubStr(trimmedLine, 1, 3) = "if ") {
            ifNestLevel++
            blockStack.add("if:" . STR(ifNestLevel))

            str newIfKeyword := "if"

            str conditionPart := SubStr(Trim(currentLine), 3)
            str modifiedIfLine := newIfKeyword . " " . conditionPart
            
            int indentLen := InStr(StrLower(currentLine), "if") - 1
            str indentation := SubStr(currentLine, 1, indentLen)

            out .= indentation . modifiedIfLine . Chr(10)
            continue 
        }

        ; ===================================================================
        ; LOOP BLOCKS
        ; ===================================================================
        if (SubStr(trimmedLine, 1, 5) = "loop,") {
            loopNestLevel++
            blockStack.add("loop:" . STR(loopNestLevel))
            str newLoopKeyword := "loop"

            str loopParams := SubStr(Trim(currentLine), 6)
            str modifiedLoopLine := newLoopKeyword . ", " . Trim(loopParams)
            int indentLen := InStr(StrLower(currentLine), "loop,") - 1
            str indentation := SubStr(currentLine, 1, indentLen)
            out .= indentation . modifiedLoopLine . Chr(10)
            continue
        }
        
        if (SubStr(trimmedLine, 1, 6) = "while ") {
            loopNestLevel++
            blockStack.add("while:" . STR(loopNestLevel))
            str newLoopKeyword := "while"
            
            str loopParams := SubStr(Trim(currentLine), 6)
            str modifiedLoopLine := newLoopKeyword . " " . loopParams
            int indentLen := InStr(StrLower(currentLine), "while") - 1
            str indentation := SubStr(currentLine, 1, indentLen)
            out .= indentation . modifiedLoopLine . Chr(10)
            continue
        }
        
                
        if (SubStr(trimmedLine, 1, 12) = "loop, parse,") {
            loopNestLevel++
            blockStack.add("loopp:" . STR(loopNestLevel))
            str newLoopKeyword := "loop, parse,"

            str loopParams := SubStr(Trim(currentLine), 12)
            str modifiedLoopLine := newLoopKeyword . " " . loopParams
            int indentLen := InStr(StrLower(currentLine), "loop, parse,") - 1
            str indentation := SubStr(currentLine, 1, indentLen)
            out .= indentation . modifiedLoopLine . Chr(10)
            continue
        }
        
        
        if (trimmedLine = "loop") {
            loopNestLevel++
            blockStack.add("loopi:" . STR(loopNestLevel))
            str newLoopKeyword := "loop"

            str loopParams := SubStr(Trim(currentLine), 4)
            str modifiedLoopLine := newLoopKeyword . "," . loopParams
            int indentLen := InStr(StrLower(currentLine), "loop") - 1
            str indentation := SubStr(currentLine, 1, indentLen)
            out .= indentation . "loop" . Chr(10)
            continue
        }
 
        ; ===================================================================
        ; BRACES HANDLING
        ; ===================================================================
        if (trimmedLine = "{") {
            continue
        }
        
        if (trimmedLine = "}") {
            if (blockStack.size() = 0) {
                out .= "SYNTAX ERROR: Unmatched closing brace found in HT-Bash." . Chr(10)
                continue
            }
            str blockInfo := blockStack[blockStack.size() - 1]
            blockStack.pop()
            str blockType := StrSplit(blockInfo, ":", 1)
            int level := INT(StrSplit(blockInfo, ":", 2))
            int indentLen := InStr(currentLine, "}") - 1
            str indentation := SubStr(currentLine, 1, indentLen)
            if (blockType = "func") {
                out .= indentation . "funcend" . Chr(10)
            } else if (blockType = "if") {
                str ender := "fi"
                out .= indentation . ender . Chr(10)
                ifNestLevel--
            } else if (blockType = "loop") {
                str ender := "done"
                out .= indentation . ender . Chr(10)
                loopNestLevel--
            } else if (blockType = "loopi") {
                str ender := "done"
                out .= indentation . ender . Chr(10)
                loopNestLevel--
            }
            else if (blockType = "while") {
                str ender := "done2"
                out .= indentation . ender . Chr(10)
                loopNestLevel--
            } else if (blockType = "loopp") {
                str ender := "pdone"
                out .= indentation . ender . Chr(10)
                loopNestLevel--
            }
            continue
        }
        
        out .= currentLine . Chr(10)
    }

    if (blockStack.size() > 0) {
        out .= "SYNTAX ERROR: " . STR(blockStack.size()) . " unclosed blocks at end of file in HT-Bash." . Chr(10)
    }

    return Trim(out)
}


func str expressionTranspiler_2(str line, int mode := 0) {
str out := ""


int isConcat := 0

int isFirstTimeMath := 0
int isFirstTimeMath2 := 0

Loop, Parse, line, " " {
if (A_LoopField = ".") {
isConcat := 1
break
}
}

if (isConcat = 1) {

Loop, Parse, line, " " {
if (RegExMatch(A_LoopField, "^-?\d+(\.\d+)?$")) {
out .= Chr(34) . A_LoopField . Chr(34) . " "
}
else if (InStr(A_LoopField, "GUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFCAA")) {
out .= A_LoopField . " "
}
else if (RegExMatch(A_LoopField, "^[a-zA-Z_][a-zA-Z0-9_]*$")) {
out .= Chr(34) . "$" . A_LoopField . Chr(34) . " "
}
else {
out .= A_LoopField . " "
}
}
line := Trim(out)

out := ""
Loop, Parse, line, " " {
if (A_LoopField = ".") {
out .= ""
}
else {
out .= A_LoopField
}
}


}
else {

if (InStr(line, " + ")) or (InStr(line, " - ")) or (InStr(line, " * ")) or (InStr(line, " / ")) or (InStr(line, " ** ")) or (InStr(line, " % ")) or (RegExMatch(line, "^-?\d+(\.\d+)?$")) {
isFirstTimeMath := 1
if (mode = 0) {
out .= "$(("
}
Loop, Parse, line, " " {

out .= A_LoopField

}
if (mode = 0) {
out .= "))"
}
}
else {
Loop, Parse, line, " " {
if (RegExMatch(A_LoopField, "^-?\d+(\.\d+)?$")) {
out .= A_LoopField . " "
}
else if (InStr(A_LoopField, "GUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFCAA")) {
out .= A_LoopField . " "
}
else if (RegExMatch(A_LoopField, "^[a-zA-Z_][a-zA-Z0-9_]*$")) {
out .= Chr(34) . "$" . A_LoopField . Chr(34) . " "
}
else {
out .= A_LoopField . " "
}
}
line := Trim(out)

}


}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





return Trim(out)
}


func str expressionTranspiler(str line, int mode := 0) {
str out := ""
str temp := ""
if (InStr(line, ".size(") = false) and (InStr(line, ".add(") = false) and (InStr(line, ".pop(") = false) {

line := Trim(StrReplace(line, "(", " ( "))
line := Trim(StrReplace(line, ")", " ) "))

if (RegExMatch(line, "(^|[^.])\b([a-zA-Z_]\w*)\s*\(")) {
line := Trim(StrReplace(line, ",", " "))
line := Trim(StrReplace(line, "  ", " "))

line := Trim(StrReplace(line, "(", " "))
line := Trim(StrReplace(line, ")", ""))

Loop, Parse, line, " " {
temp := Trim(A_LoopField)
if (A_Index = 0) {
out .= "$(" . A_LoopField . " "
}
else {
if (InStr(temp, "[@]")) {

out .= StringTrimRight(temp, 3) . " "
}
else {
out .= expressionTranspiler_2(A_LoopField, mode) . " "
}

}
}

out := Trim(out) . ")"

}
else {
out := expressionTranspiler_2(line, mode)
}

}
else {
out := Trim(line)
}

out := RegExReplace(out, "([a-zA-Z0-9_]+)\[(.*?)\]", Chr(34) . "${$1[$2]}" . Chr(34))
out := RegExReplace(out, "([a-zA-Z0-9_]+)\.size\(\)", "${#$1[@]}")

return Trim(out)
}



main

str code := ""
str out := ""

str str1 := ""
str str2 := ""
str str3 := ""
str str4 := ""
str str5 := ""
str str6 := ""
str str7 := ""
str str8 := ""
str str9 := ""

int whereBeginFuncOptanalParams := 0
int whereBeginFuncOptanalParams_help := 0
int whereBeginFuncOptanalParams_help_once := 0


str outTemp1 := ""
str outTemp2 := ""
str outTemp3 := ""
str outTemp4 := ""
int count := 0

int mathMode := 0

int firstLoop := 0
int firstLoop_parse := 0

int firstLoop_func := 0
int firstLoop_parse_func := 0
int inFunc := 0

str fix_curly_else_if := ""
arr str fix_curly_else_if_ARR

arr str fixCode_runARR
str fixCode_run := ""
int fixCode_run_INT := 0

str params := getLangParams("HT-Bash", "htsh")
if (params != "") {
code := FileRead(params)

Loop, Parse, code, `n, `r {
if (SubStr(StrLower(Trim(A_LoopField)), 1, 4) = "run ") {
str1 := Trim(StringTrimLeft(Trim(A_LoopField), 4))
fixCode_runARR.add(str1)
fixCode_run .= "run ht-bash_runrsfdhgiosdxxszpxx--ashdzxkcxwaSsdx--AA" . STR(fixCode_run_INT) . "AA" . Chr(10)
fixCode_run_INT++
}
else {
fixCode_run .= A_LoopField . Chr(10)
}

}

code := Trim(fixCode_run)


code := cleanUpFirst(code)
code := preserveStrings(code)
code := handleComments(code, ";")
code := formatCurlyBracesForParsing(code)

; code

if (InStr(code, "{")) {

fix_curly_else_if := ""


Loop, Parse, code, `n, `r {
fix_curly_else_if_ARR.add(A_LoopField)
}
fix_curly_else_if_ARR.add(" ")

Loop, Parse, code, `n, `r {

if (Trim(A_LoopField) = "}") and (SubStr(Trim(StrLower(fix_curly_else_if_ARR[A_Index + 1])), 1, 8) = "else if ") {
fix_curly_else_if .= ""
}
else if (Trim(A_LoopField) = "{") and (SubStr(Trim(StrLower(fix_curly_else_if_ARR[A_Index - 1])), 1, 8) = "else if ") {
fix_curly_else_if .= ""
}
else if (Trim(A_LoopField) = "}") and (Trim(StrLower(fix_curly_else_if_ARR[A_Index + 1])) = "else") {
fix_curly_else_if .= ""
}
else if (Trim(A_LoopField) = "{") and (Trim(StrLower(fix_curly_else_if_ARR[A_Index - 1])) = "else") {
fix_curly_else_if .= ""
}
else {
fix_curly_else_if .= A_LoopField . Chr(10)
}


}
code := Trim(fix_curly_else_if)


code := transformBracesToHT_Bash(code)
}

Loop, Parse, code, `n, `r {
if (SubStr(StrLower(Trim(A_LoopField)), 1, 4) = "run ") {
str1 := Trim(StringTrimLeft(A_LoopField, 4))
out .= str1 . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 5) = "func ") {
firstLoop_func := 0
firstLoop_parse_func := 0
inFunc := 1

str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str6 := ""
str7 := ""
str8 := ""
str9 := ""

whereBeginFuncOptanalParams := 0
whereBeginFuncOptanalParams_help := 0
whereBeginFuncOptanalParams_help_once := 0

str1 := Trim(StringTrimLeft(A_LoopField, 5))
str1 := Trim(StringTrimRight(str1, 1))

str2 := Trim(StrSplit(str1, "(", 1))
str3 := Trim(StrSplit(str1, "(", 2))
out .= str2 . "() {" . Chr(10)
str4 := ""
if (str3 != "") {
str4 := ""


str6 := ""
str7 := ""
whereBeginFuncOptanalParams := 0
Loop, Parse, str3, "," {
str5 := ""
if (InStr(A_LoopField, " := ")) {
whereBeginFuncOptanalParams_help_once++
if (whereBeginFuncOptanalParams_help_once = 1) {
whereBeginFuncOptanalParams := A_Index + 1
}

str5 := Trim(StrSplit(A_LoopField, " := ", 1))
str7 .= Trim(StrSplit(A_LoopField, " := ", 1)) . Chr(10)
str6 .= expressionTranspiler(Trim(StrSplit(A_LoopField, " := ", 2))) . Chr(10)

if (InStr(str5, "[@]")) {
str5 := Trim(str5)
str5 := StringTrimRight(str5, 3)
str4 .= "local -n " . Trim(str5) . "=" . "$" . STR(A_Index + 1) . Chr(10)
}
else if (InStr(str5, "[]")) {
str5 := Trim(str5)
str5 := StringTrimRight(str5, 2)
str4 .= "local -n " . Trim(str5) . "=" . "$" . STR(A_Index + 1) . Chr(10)
}
else {
str4 .= "local " . Trim(str5) . "=" . Chr(34) . "$" . STR(A_Index + 1) . Chr(34) . Chr(10)
}


}
else {
str5 := A_LoopField
if (InStr(str5, "[@]")) {
str5 := Trim(str5)
str5 := StringTrimRight(str5, 3)
str4 .= "local -n " . Trim(str5) . "=" . "$" . STR(A_Index + 1) . Chr(10)
}
else if (InStr(str5, "[]")) {
str5 := Trim(str5)
str5 := StringTrimRight(str5, 2)
str4 .= "local -n " . Trim(str5) . "=" . "$" . STR(A_Index + 1) . Chr(10)
}
else {
str4 .= "local " . Trim(str5) . "=" . Chr(34) . "$" . STR(A_Index + 1) . Chr(34) . Chr(10)
}
}
}
}
out .= Trim(str4) . Chr(10)

if (str6 != "") {
str8 := ""
whereBeginFuncOptanalParams_help := 0
Loop, Parse, str6, `n, `r {

whereBeginFuncOptanalParams_help := A_Index
Loop, Parse, str7, `n, `r {
if (A_Index = whereBeginFuncOptanalParams_help) {
str8 := A_LoopField
break
}
}

out .= "[ " . Chr(34) . "$#" . Chr(34) . " -lt " . STR(whereBeginFuncOptanalParams) . " ] && " . Trim(str8) . "=" . Trim(A_LoopField) . Chr(10)
whereBeginFuncOptanalParams++
}
}


}
else if (Trim(StrLower(A_LoopField)) = "funcend") or (Trim(StrLower(A_LoopField)) = "endfunc") {
out .= "}" . Chr(10)
inFunc := 0
}
else if (Trim(StrLower(A_LoopField)) = "return") {
out .= "echo" . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "return ") {
str1 := Trim(StringTrimLeft(A_LoopField, 7))
out .= "echo " . expressionTranspiler(str1) . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 11) = "return_arr ") {
str1 := Trim(StringTrimLeft(A_LoopField, 11))
out .= "printf " . Chr(34) . "%s\n" . Chr(34) . " " . expressionTranspiler(str1) . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 6) = "print(") {

str1 := Trim(StringTrimLeft(A_LoopField, 6))
str1 := Trim(StringTrimRight(str1, 1))

if (InStr(str1, "GUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFCAA")) {
    out .= "printf " . Chr(34) . "%s\n" . Chr(34) . " " . Trim(str1) . " >&2" . Chr(10)
}
else {
    out .= "printf " . Chr(34) . "%s\n" . Chr(34) . " " . expressionTranspiler(str1) . " >&2" . Chr(10)
}


}
else if (SubStr(StrLower(A_LoopField), 1, 10) = "local arr ") {

str1 := Trim(StringTrimLeft(A_LoopField, 10))
str2 := Trim(StrSplit(str1, " := ", 1))
str3 := Trim(StrSplit(str1, " := ", 2))

if (InStr(str1, " := ")) {

str3 := StrReplace(str3, "[", "")
str3 := StrReplace(str3, "]", "")
str4 := ""
if (InStr(str3, ",")) {
Loop, Parse, str3, "," {
str4 .= expressionTranspiler(A_LoopField) . " "
}
str3 := Trim(str4)

}

out .= "local " . str2 . "=(" . str3 . ")" . Chr(10)
}
else {
out .= "local " . str2 . "=(" . expressionTranspiler(str3) . ")" . Chr(10)
}
}
else if (SubStr(StrLower(A_LoopField), 1, 10) = "local str ") or (SubStr(StrLower(A_LoopField), 1, 10) = "local int ") or (SubStr(StrLower(A_LoopField), 1, 10) = "local var ") {

str1 := Trim(StringTrimLeft(A_LoopField, 10))


str2 := Trim(StrSplit(str1, " := ", 1))
str3 := Trim(StrSplit(str1, " := ", 2))

    out .= "local " . str2 . "=" . expressionTranspiler(str3) . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 6) = "local ") and (InStr(A_LoopField, " := ")) {

str1 := Trim(StringTrimLeft(A_LoopField, 6))

str1 := Trim(A_LoopField)

str2 := Trim(StrSplit(str1, " := ", 1))
str3 := Trim(StrSplit(str1, " := ", 2))

    out .= str2 . "=" . expressionTranspiler(str3) . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "str ") or (SubStr(StrLower(A_LoopField), 1, 4) = "int ") or (SubStr(StrLower(A_LoopField), 1, 4) = "var ") {

str1 := Trim(StringTrimLeft(A_LoopField, 4))


str2 := Trim(StrSplit(str1, " := ", 1))
str3 := Trim(StrSplit(str1, " := ", 2))

    out .= str2 . "=" . expressionTranspiler(str3) . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "arr ") {

str1 := Trim(StringTrimLeft(A_LoopField, 4))
str2 := Trim(StrSplit(str1, " := ", 1))
str3 := Trim(StrSplit(str1, " := ", 2))
if (InStr(str1, " := ")) {

str3 := StrReplace(str3, "[", "")
str3 := StrReplace(str3, "]", "")
str4 := ""
if (InStr(str3, ",")) {
Loop, Parse, str3, "," {
str4 .= expressionTranspiler(A_LoopField) . " "
}
str3 := Trim(str4)

}

out .= str2 . "=(" . str3 . ")" . Chr(10)
}
else {
out .= str2 . "=(" . expressionTranspiler(str3) . ")" . Chr(10)
}
}
else if (InStr(A_LoopField, " := []")) {
str1 := Trim(A_LoopField)
str2 := Trim(StrSplit(str1, " := ", 1))
out .= str2 . "=()" . Chr(10)
}
else if (InStr(A_LoopField, ".add(")) {
str1 := Trim(A_LoopField)
str1 := Trim(StringTrimRight(str1, 1))

str2 := Trim(StrSplit(str1, ".add(", 1))
str3 := Trim(StrSplit(str1, ".add(", 2))

out .= str2 . "+=(" . expressionTranspiler(str3) . ")" . Chr(10)
}
else if (InStr(A_LoopField, ".pop()")) {
str1 := Trim(A_LoopField)
str1 := Trim(StringTrimRight(str1, 1))

str2 := Trim(StrSplit(str1, ".pop(", 1))

out .= str2 . "=(" . Chr(34) . "${" . str2 . "[@]:0:${#" . str2 . "[@]}-1}" . Chr(34) . ")" . Chr(10)
}

else if (InStr(A_LoopField, " := ")) and (InStr(A_LoopField, " [")) and (InStr(A_LoopField, "]")) {

str1 := Trim(A_LoopField)

if (InStr(str1, " := ")) {
str2 := Trim(StrSplit(str1, " := ", 1))
str3 := Trim(StrSplit(str1, " := ", 2))

str3 := StrReplace(str3, "[", "")
str3 := StrReplace(str3, "]", "")
str4 := ""
if (InStr(str3, ",")) {
Loop, Parse, str3, "," {
str4 .= expressionTranspiler(A_LoopField) . " "
}
str3 := Trim(str4)

}

out .= str2 . "=(" . str3 . ")" . Chr(10)
}
else {
out .= str2 . "=(" . expressionTranspiler(str3) . ")" . Chr(10)
}
}
else if (InStr(A_LoopField, " := @")) {

str1 := Trim(A_LoopField)

str2 := Trim(StrSplit(str1, " := @", 1))
str3 := Trim(StrSplit(str1, " := @", 2))

str3 := Trim(expressionTranspiler(str3))
str3 := Trim(StringTrimLeft(str3, 1))

out .= "mapfile -t " . str2 . " < <" . str3 . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 13) = "loop, parse, ") {
str1 := Trim(StringTrimLeft(A_LoopField, 13))

if (inFunc = 0) {

firstLoop++
firstLoop_parse++

if (firstLoop = 1) {
    out .= "A_Index_stack=()" . Chr(10)
    out .= "A_Index=0" . Chr(10)
}
if (firstLoop_parse = 1) {
    out .= "A_LoopField_stack=()" . Chr(10)
    out .= "A_LoopField=" . Chr(34) . Chr(34) . Chr(10)
}

    out .= "A_Index_stack+=(" . Chr(34) . "$A_Index" . Chr(34) . ")" . Chr(10)
    out .= "A_LoopField_stack+=(" . Chr(34) . "$A_LoopField" . Chr(34) . ")" . Chr(10)

if (InStr(str1, ",")) {
str2 := Trim(StrSplit(str1, ",", 1))
str3 := Trim(StrSplit(str1, ",", 2))

str4 := Chr(10)
str4 .= "_parse_str=" . Chr(34) . "$" . str2 . Chr(34) . Chr(10)

str4 .= "_parse_delim=" . str3 . Chr(10)
str4 .= "_temp_arr_" . STR(firstLoop_parse) . "=(); IFS=" . Chr(34) . "$_parse_delim" . Chr(34) . " read -r -d '' -a _temp_arr_" . STR(firstLoop_parse) . " <<< " . Chr(34) . "$_parse_str" . Chr(34) . "; _temp_arr_" . STR(firstLoop_parse) . "[-1]=" . Chr(34) . "${_temp_arr_" . STR(firstLoop_parse) . "[-1]%$'\n'}" . Chr(34) . Chr(10)

str4 .= "for ((A_Index=0; A_Index<${#_temp_arr_" . STR(firstLoop_parse) . "[@]}; A_Index++)); do" . Chr(10)
str4 .= "A_LoopField=" . Chr(34) . "${_temp_arr_" . STR(firstLoop_parse) . "[$A_Index]}" . Chr(34) . Chr(10)

}
else {
;;;;;;;;;;;;;;
;;;;;;;;;;;;;;
str2 := Trim(str1)

str4 := Chr(10)

str4 .= "_temp_arr_" . STR(firstLoop_parse) . "=" . Chr(34) . "$" . str2 . Chr(34) . Chr(10)

str4 .= "for ((A_Index=0; A_Index<${#_temp_arr_" . STR(firstLoop_parse) . "}; A_Index++)); do" . Chr(10)

str4 .= "A_LoopField=" . Chr(34) . "${_temp_arr_" . STR(firstLoop_parse) . ":A_Index:1}" . Chr(34) . Chr(10)

;;;;;;;;;;;;;;
;;;;;;;;;;;;;;
}


    out .= str4 . Chr(10)
    
    
    
}
else {
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

firstLoop_func++
firstLoop_parse_func++

if (firstLoop_func = 1) {
    out .= "local A_Index_stack=()" . Chr(10)
    out .= "local A_Index=0" . Chr(10)
}
if (firstLoop_parse_func = 1) {
    out .= "local A_LoopField_stack=()" . Chr(10)
    out .= "local A_LoopField=" . Chr(34) . Chr(34) . Chr(10)
}

    out .= "A_Index_stack+=(" . Chr(34) . "$A_Index" . Chr(34) . ")" . Chr(10)
    out .= "A_LoopField_stack+=(" . Chr(34) . "$A_LoopField" . Chr(34) . ")" . Chr(10)

if (InStr(str1, ",")) {
str2 := Trim(StrSplit(str1, ",", 1))
str3 := Trim(StrSplit(str1, ",", 2))

str4 := Chr(10)
str4 .= "local _parse_str=" . Chr(34) . "$" . str2 . Chr(34) . Chr(10)

str4 .= "local _parse_delim=" . str3 . Chr(10)
str4 .= "local -a _temp_arr_" . STR(firstLoop_parse_func) . "; IFS=" . Chr(34) . "$_parse_delim" . Chr(34) . " read -r -d '' -a _temp_arr_" . STR(firstLoop_parse_func) . " <<< " . Chr(34) . "$_parse_str" . Chr(34) . "; _temp_arr_" . STR(firstLoop_parse_func) . "[-1]=" . Chr(34) . "${_temp_arr_" . STR(firstLoop_parse_func) . "[-1]%$'\n'}" . Chr(34) . Chr(10)


str4 .= "for ((A_Index=0; A_Index<${#_temp_arr_" . STR(firstLoop_parse_func) . "[@]}; A_Index++)); do" . Chr(10)
str4 .= "A_LoopField=" . Chr(34) . "${_temp_arr_" . STR(firstLoop_parse_func) . "[$A_Index]}" . Chr(34) . Chr(10)

}
else {
;;;;;;;;;;;;;;
;;;;;;;;;;;;;;
str2 := Trim(str1)

str4 := Chr(10)

str4 .= "local _temp_arr_" . STR(firstLoop_parse_func) . "=" . Chr(34) . "$" . str2 . Chr(34) . Chr(10)

str4 .= "for ((A_Index=0; A_Index<${#_temp_arr_" . STR(firstLoop_parse_func) . "}; A_Index++)); do" . Chr(10)

str4 .= "A_LoopField=" . Chr(34) . "${_temp_arr_" . STR(firstLoop_parse_func) . ":A_Index:1}" . Chr(34) . Chr(10)

;;;;;;;;;;;;;;
;;;;;;;;;;;;;;
}


    out .= str4 . Chr(10)
    
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
}
    
    
    
    
    
}
else if (SubStr(StrLower(A_LoopField), 1, 6) = "loop, ") {
str1 := Trim(StringTrimLeft(A_LoopField, 6))

if (inFunc = 0) {

firstLoop++
if (firstLoop = 1) {
    out .= "A_Index_stack=()" . Chr(10)
    out .= "A_Index=0" . Chr(10)
}
    out .= "A_Index_stack+=(" . Chr(34) . "$A_Index" . Chr(34) . ")" . Chr(10)
if (InStr(str1, ".size(")) {
    out .= "for ((A_Index=0; A_Index<" . expressionTranspiler(Trim(str1)) . "; A_Index++)); do" . Chr(10)
}
else {
    out .= "for ((A_Index=0; A_Index<" . Trim(str1) . "; A_Index++)); do" . Chr(10)
}

}
else {

firstLoop_func++
if (firstLoop_func = 1) {
    out .= "local A_Index_stack=()" . Chr(10)
    out .= "local A_Index=0" . Chr(10)
}
    out .= "A_Index_stack+=(" . Chr(34) . "$A_Index" . Chr(34) . ")" . Chr(10)
if (InStr(str1, ".size(")) {
    out .= "for ((A_Index=0; A_Index<" . expressionTranspiler(Trim(str1)) . "; A_Index++)); do" . Chr(10)
}
else {
    out .= "for ((A_Index=0; A_Index<" . Trim(str1) . "; A_Index++)); do" . Chr(10)
}

}

}
else if (Trim(StrLower(A_LoopField)) = "loop") {


if (inFunc = 0) {

firstLoop++
if (firstLoop = 1) {
    out .= "A_Index_stack=()" . Chr(10)
    out .= "A_Index=0" . Chr(10)
}
    out .= "A_Index_stack+=(" . Chr(34) . "$A_Index" . Chr(34) . ")" . Chr(10)

    out .= "for ((A_Index=0;; A_Index++)); do" . Chr(10)
}
else {


firstLoop_func++
if (firstLoop_func = 1) {
    out .= "local A_Index_stack=()" . Chr(10)
    out .= "local A_Index=0" . Chr(10)
}
    out .= "A_Index_stack+=(" . Chr(34) . "$A_Index" . Chr(34) . ")" . Chr(10)

    out .= "for ((A_Index=0;; A_Index++)); do" . Chr(10)
}

}
else if (Trim(A_LoopField) = "done") {

    out .= Trim(A_LoopField) . Chr(10)
    out .= "A_Index=" . Chr(34) . "${A_Index_stack[-1]}" . Chr(34) . Chr(10)
    out .= "unset 'A_Index_stack[-1]'" . Chr(10)
}
else if (Trim(A_LoopField) = "pdone") {

    out .= "done" . Chr(10)

    out .= "A_Index=" . Chr(34) . "${A_Index_stack[-1]}" . Chr(34) . Chr(10)
    out .= "unset 'A_Index_stack[-1]'" . Chr(10)

    out .= "A_LoopField=" . Chr(34) . "${A_LoopField_stack[-1]}" . Chr(34) . Chr(10)
    out .= "unset 'A_LoopField_stack[-1]'" . Chr(10)
}
else if (Trim(A_LoopField) = "break") {
    out .= Trim(A_LoopField) . Chr(10)
}
else if (Trim(A_LoopField) = "continue") {
    out .= Trim(A_LoopField) . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 3) = "if ") or (SubStr(StrLower(A_LoopField), 1, 8) = "else if ") {


if (SubStr(StrLower(A_LoopField), 1, 8) = "else if ") {
str1 := Trim(StringTrimLeft(A_LoopField, 8))

}
else {
str1 := Trim(StringTrimLeft(A_LoopField, 3))
}

mathMode := 0
if (getLastChars(Trim(A_LoopField), 1) = ")") {
str1 := Trim(StringTrimLeft(str1, 1))
str1 := Trim(StringTrimRight(str1, 1))
mathMode := 1
}
str2 := ""
Loop, Parse, str1, " " {

if (RegExMatch(A_LoopField, "^-?\d+(\.\d+)?$")) {
str2 .= A_LoopField . " "
mathMode := 1
}
else if (A_LoopField = ".") {
str2 .= ""
}
else if (A_LoopField = "==") {
str2 .= " == "
}
else if (A_LoopField = "=") {
str2 .= " == "
}
else if (A_LoopField = ">") {
str2 .= " > "
}
else if (A_LoopField = "<") {
str2 .= " < "
}
else if (A_LoopField = ">=") {
str2 .= " >= "
}
else if (A_LoopField = "<=") {
str2 .= " <= "
}
else if (A_LoopField = "!=") {
str2 .= " != "
}
else {
if (mathMode = 0) {
str2 .= expressionTranspiler(A_LoopField)
}
else {
str2 .= A_LoopField . " "
}

}
}


if (SubStr(StrLower(A_LoopField), 1, 8) = "else if ") {
if (mathMode = 0) {
    out .= "elif [[ " . str2 . " ]]; then" . Chr(10)
}
else {
    out .= "elif (( " . str2 . " )); then" . Chr(10)
}
}
else {
if (mathMode = 0) {
    out .= "if [[ " . str2 . " ]]; then" . Chr(10)
}
else {
    out .= "if (( " . str2 . " )); then" . Chr(10)
}
}

}
else if (Trim(A_LoopField) = "fi") {
    out .= Trim(A_LoopField) . Chr(10)
}
else if (Trim(A_LoopField) = "else") {
    out .= Trim(A_LoopField) . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 6) = "while ") {



str1 := Trim(StringTrimLeft(A_LoopField, 6))

mathMode := 0
if (getLastChars(Trim(A_LoopField), 1) = ")") {
str1 := Trim(StringTrimLeft(str1, 1))
str1 := Trim(StringTrimRight(str1, 1))
mathMode := 1
}
str2 := ""
Loop, Parse, str1, " " {

if (RegExMatch(A_LoopField, "^-?\d+(\.\d+)?$")) {
str2 .= A_LoopField . " "
mathMode := 1
}
else if (A_LoopField = ".") {
str2 .= ""
}
else if (A_LoopField = "==") {
str2 .= " == "
}
else if (A_LoopField = "=") {
str2 .= " == "
}
else if (A_LoopField = ">") {
str2 .= " > "
}
else if (A_LoopField = "<") {
str2 .= " < "
}
else if (A_LoopField = ">=") {
str2 .= " >= "
}
else if (A_LoopField = "<=") {
str2 .= " <= "
}
else if (A_LoopField = "!=") {
str2 .= " != "
}
else {
if (mathMode = 0) {
str2 .= expressionTranspiler(A_LoopField)
}
else {
str2 .= A_LoopField . " "
}

}
}

if (mathMode = 0) {
    out .= "while [[ " . str2 . " ]]; do" . Chr(10)
}
else {
    out .= "while (( " . str2 . " )); do" . Chr(10)
}


}
else if (Trim(A_LoopField) = "done2") {
    out .= "done" . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 6) = "local ") and (InStr(A_LoopField, " := ")) {

str1 := Trim(StringTrimLeft(A_LoopField, 6))

str1 := Trim(A_LoopField)

str2 := Trim(StrSplit(str1, " := ", 1))
str3 := Trim(StrSplit(str1, " := ", 2))

    out .= "local " . str2 . "=" . expressionTranspiler(str3) . Chr(10)
}
else if (InStr(A_LoopField, " := ")) {

str1 := Trim(A_LoopField)

str2 := Trim(StrSplit(str1, " := ", 1))
str3 := Trim(StrSplit(str1, " := ", 2))

    out .= str2 . "=" . expressionTranspiler(str3) . Chr(10)
}
else if (InStr(A_LoopField, " += ")) {
    str1 := Trim(A_LoopField)
    str2 := Trim(StrSplit(str1, " += ", 1))
    str3 := Trim(StrSplit(str1, " += ", 2))
    out .= "(( " . str2 . " += " . expressionTranspiler(str3, 1) . " ))" . Chr(10)
}

else if (InStr(A_LoopField, " -= ")) {
    str1 := Trim(A_LoopField)
    str2 := Trim(StrSplit(str1, " -= ", 1))
    str3 := Trim(StrSplit(str1, " -= ", 2))
    out .= "(( " . str2 . " -= " . expressionTranspiler(str3, 1) . " ))" . Chr(10)
}

else if (InStr(A_LoopField, " *= ")) {
    str1 := Trim(A_LoopField)
    str2 := Trim(StrSplit(str1, " *= ", 1))
    str3 := Trim(StrSplit(str1, " *= ", 2))
    out .= "(( " . str2 . " *= " . expressionTranspiler(str3, 1) . " ))" . Chr(10)
}

else if (InStr(A_LoopField, " /= ")) {
    str1 := Trim(A_LoopField)
    str2 := Trim(StrSplit(str1, " /= ", 1))
    str3 := Trim(StrSplit(str1, " /= ", 2))
    out .= "(( " . str2 . " /= " . expressionTranspiler(str3, 1) . " ))" . Chr(10)
}

else if (InStr(A_LoopField, " %= ")) {
    str1 := Trim(A_LoopField)
    str2 := Trim(StrSplit(str1, " %= ", 1))
    str3 := Trim(StrSplit(str1, " %= ", 2))
    out .= "(( " . str2 . " %= " . expressionTranspiler(str3, 1) . " ))" . Chr(10)
}

else if (InStr(A_LoopField, " **= ")) {
    str1 := Trim(A_LoopField)
    str2 := Trim(StrSplit(str1, " **= ", 1))
    str3 := Trim(StrSplit(str1, " **= ", 2))
    out .= "(( " . str2 . " = " . str2 . " ** " . expressionTranspiler(str3, 1) . " ))" . Chr(10)
}
else if (InStr(A_LoopField, " .= ")) {

str1 := Trim(A_LoopField)

str2 := Trim(StrSplit(str1, " .= ", 1))
str3 := Trim(StrSplit(str1, " .= ", 2))

    out .= str2 . "+=" . expressionTranspiler(str3) . Chr(10)
}
else if (getLastChars(Trim(A_LoopField), 2) = "++") {

str1 := Trim(A_LoopField)

str1 := StringTrimRight(str1, 2)

    out .= "(( " . str1 . "++ ))" . Chr(10)
}
else if (getLastChars(Trim(A_LoopField), 2) = "--") {

str1 := Trim(A_LoopField)

str1 := StringTrimRight(str1, 2)

    out .= "(( " . str1 . "-- ))" . Chr(10)
}
else if (getLastChars(Trim(A_LoopField), 1) = ")") {

str1 := Trim(A_LoopField)
str1 := expressionTranspiler(str1)
str1 := StringTrimLeft(str1, 2)
str1 := StringTrimRight(str1, 1)

str1 := StrReplace(str1, Chr(34) . "(", " ")

    out .= str1 . Chr(10)
}
else {
; else we allow stuff e.g.: program param param param ... so we can allow anything else
    out .= A_LoopField . Chr(10)
}
}


code := StringTrimRight(out, 1)
; end code

code := restoreStrings_bash(code)
code := StrReplace(code, Chr(34) . "$" . Chr(34), "")

code := StrReplace(code, Chr(34) . "ihuiuuhuuhtheidFor-" . Chr(45) . "asdsas--theuhtuwaesphoutr" , "\")

Loop, fixCode_runARR.size() {
code := StrReplace(code, "ht-bash_runrsfdhgiosdxxszpxx--ashdzxkcxwaSsdx--AA" . STR(A_Index) . "AA", fixCode_runARR[A_Index])
}

code := "#!/usr/bin/env bash" . Chr(10) . "if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 3))); then" . Chr(10) . "    echo " . Chr(34) . "Error: This script requires Bash 4.3+. Update bash." . Chr(34) . " >&2" . Chr(10) . "    exit 1" . Chr(10) . "fi" . Chr(10) . Chr(10) . "source " . Chr(34) . "$(dirname " . Chr(34) . "$0" . Chr(34) . ")/HT-Bash_Lib.sh" . Chr(34) . Chr(10) . code

saveOutput(code, StringTrimRight(params, 4) . "sh")
}
